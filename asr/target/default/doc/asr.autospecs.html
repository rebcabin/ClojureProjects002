<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>asr.autospecs documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Asr</span> <span class="project-version">0.1.0-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="intro.html"><div class="inner"><span>Introduction to asr</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>asr</span></div></div></li><li class="depth-2 branch"><a href="asr.asr.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>asr</span></div></a></li><li class="depth-2 branch current"><a href="asr.autospecs.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>autospecs</span></div></a></li><li class="depth-2 branch"><a href="asr.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="asr.data.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>data</span></div></a></li><li class="depth-2 branch"><a href="asr.grammar.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>grammar</span></div></a></li><li class="depth-2 branch"><a href="asr.parsed.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>parsed</span></div></a></li><li class="depth-2 branch"><a href="asr.specs.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>specs</span></div></a></li><li class="depth-2"><a href="asr.utils.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>utils</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="asr.autospecs.html#var-do-one-tuple-spec-head-and-term.21"><div class="inner"><span>do-one-tuple-spec-head-and-term!</span></div></a></li><li class="depth-1"><a href="asr.autospecs.html#var-do-synnasr"><div class="inner"><span>do-synnasr</span></div></a></li><li class="depth-1"><a href="asr.autospecs.html#var-dummy-generator-for-heads"><div class="inner"><span>dummy-generator-for-heads</span></div></a></li><li class="depth-1"><a href="asr.autospecs.html#var-dummy-lpred"><div class="inner"><span>dummy-lpred</span></div></a></li><li class="depth-1"><a href="asr.autospecs.html#var-heads-for-composite"><div class="inner"><span>heads-for-composite</span></div></a></li><li class="depth-1"><a href="asr.autospecs.html#var-spec-from-arg"><div class="inner"><span>spec-from-arg</span></div></a></li><li class="depth-1"><a href="asr.autospecs.html#var-spec-from-args"><div class="inner"><span>spec-from-args</span></div></a></li><li class="depth-1"><a href="asr.autospecs.html#var-spec-from-composite"><div class="inner"><span>spec-from-composite</span></div></a></li><li class="depth-1"><a href="asr.autospecs.html#var-spec-from-head-and-args"><div class="inner"><span>spec-from-head-and-args</span></div></a></li><li class="depth-1"><a href="asr.autospecs.html#var-spec-from-symconst-stuff"><div class="inner"><span>spec-from-symconst-stuff</span></div></a></li><li class="depth-1"><a href="asr.autospecs.html#var-symconst-spec-for-term"><div class="inner"><span>symconst-spec-for-term</span></div></a></li><li class="depth-1"><a href="asr.autospecs.html#var-tuple-head-spec-from-stuff"><div class="inner"><span>tuple-head-spec-from-stuff</span></div></a></li><li class="depth-1"><a href="asr.autospecs.html#var-tuple-stuffs"><div class="inner"><span>tuple-stuffs</span></div></a></li><li class="depth-1"><a href="asr.autospecs.html#var-tuple-stuffss-by-term"><div class="inner"><span>tuple-stuffss-by-term</span></div></a></li><li class="depth-1"><a href="asr.autospecs.html#var-tuple-term-spec-from-stuffs"><div class="inner"><span>tuple-term-spec-from-stuffs</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">asr.autospecs</h1><div class="doc"><div class="markdown"></div></div><div class="public anchor" id="var-do-one-tuple-spec-head-and-term.21"><h3>do-one-tuple-spec-head-and-term!</h3><div class="usage"><code>(do-one-tuple-spec-head-and-term! term)</code></div><div class="doc"><div class="markdown"><p>Spec one tuple type, head-spec and term-spec, by term.</p>
</div></div></div><div class="public anchor" id="var-do-synnasr"><h3>do-synnasr</h3><div class="usage"><code>(do-synnasr)</code></div><div class="doc"><div class="markdown"><p>Automated items for the spec registry. W.I.P.</p>
</div></div></div><div class="public anchor" id="var-dummy-generator-for-heads"><h3>dummy-generator-for-heads</h3><div class="usage"><code>(dummy-generator-for-heads heads)</code></div><div class="doc"><div class="markdown"><p>A dummy generator for argument lists for heads which just inserts a list of random length of random identifiers. Not suitable long-term.</p>
</div></div></div><div class="public anchor" id="var-dummy-lpred"><h3>dummy-lpred</h3><div class="usage"><code>(dummy-lpred heads)</code></div><div class="doc"><div class="markdown"><p>A predicate for dummy specs that checks simply that the instance is a list with an appropriate head and zero or more items of any type. Not suitable long-term.</p>
</div></div></div><div class="public anchor" id="var-heads-for-composite"><h3>heads-for-composite</h3><div class="usage"><code>(heads-for-composite term)</code></div><div class="doc"><div class="markdown"><p>Produce a list of symbolic heads (like ’RealUnaryMinus and ’ArraySection), from a term like :asr.core/expr. See all-heads-for-exprs-test in core_test.clj.</p>
</div></div></div><div class="public anchor" id="var-spec-from-arg"><h3>spec-from-arg</h3><div class="usage"><code>(spec-from-arg arg)</code></div><div class="doc"><div class="markdown"><h3><a href="#spec-fragment-from-arg-args" id="spec-fragment-from-arg-args"></a>Spec Fragment from Arg, Args</h3>
<p>Convert multiplicities into clojure.spec equivalents.</p>
</div></div></div><div class="public anchor" id="var-spec-from-args"><h3>spec-from-args</h3><div class="usage"><code>(spec-from-args args)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-spec-from-composite"><h3>spec-from-composite</h3><div class="usage"><code>(spec-from-composite composite)</code></div><div class="doc"><div class="markdown"><h1><a href="#back-patching-symbol" id="back-patching-symbol"></a>Back-patching Symbol</h1>
<p>TODO</p>
<h1><a href="#first-composite-spec-translationunit" id="first-composite-spec-translationunit"></a>First Composite Spec: <code>TranslationUnit</code></h1>
<p>Write specs as data lists and <code>eval</code> them later. Turns out it’s necessary to do that, and it’s a beneficial accident lest we clutter up the namespace of specs.</p>
<p>Composites and tuples have lists of type-var pairs, that is, of args. We’ve already handled arg lists in <code>spec-from-args</code> above.</p>
<p>Specs for all tuples’ heads and terms have already been registered.</p>
<p>Specs for all symconsts’ heads and terms have already been registered.</p>
</div></div></div><div class="public anchor" id="var-spec-from-head-and-args"><h3>spec-from-head-and-args</h3><div class="usage"><code>(spec-from-head-and-args head args)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-spec-from-symconst-stuff"><h3>spec-from-symconst-stuff</h3><div class="usage"><code>(spec-from-symconst-stuff symconst-stuff)</code></div><div class="doc"><div class="markdown"><h2><a href="#symconst-head-specs" id="symconst-head-specs"></a>Symconst-Head-Specs</h2>
<p>This next code block REGISTERS the (about) 72 head-specs by <code>eval</code>’ing the <code>s/defs</code> written by <code>`(s/def ...)</code>. A spec is <em>registered</em> into a hidden Clojure Spec Registry by side-effect and is associated with the namespaced keyword produced by <code>nskw-kebab-from</code>. Once this next code block runs, we’ll have (about) 72 head-specs magically registered and we can refer to them by namespaced kebab’bed keyword name. For example, <code>::implementation</code> will be registered and we can refer to it via <code>(s/spec ::implementation)</code>.</p>
<p>All specs, head-specs and term-specs alike must be registered before being referred-to. Later, we’ll break co-recursive cycles by registering defective specs then backpatching them. For example, the term-spec for <code>::symbol</code> refers to the term-spec for <code>::symbol-table</code>, which refers to the term-spec for <code>::symbol</code>. Clojure.spec can’t tolerate that, but it can tolerate a defective term-spec for <code>::symbol-table</code> that we backpatch later.</p>
<p>Construct and register all (approximately) 72 symconst head-specs:</p>
</div></div></div><div class="public anchor" id="var-symconst-spec-for-term"><h3>symconst-spec-for-term</h3><div class="usage"><code>(symconst-spec-for-term stuffs-for-term)</code></div><div class="doc"><div class="markdown"><h3><a href="#symconst-spec-for-term-sic" id="symconst-spec-for-term-sic"></a>Symconst Spec for Term <a href="sic">sic</a></h3>
<p>For each term, write a <code>set</code> containing its alternative heads, e.g., the term <code>binop</code> is one of the ten heads <code>Add</code>, <code>Sub</code>, and so on, to <code>BitRShift</code>.</p>
<p>To unit-test <code>spec-for-term</code>, <code>eval</code> one of them and check it:</p>
</div></div></div><div class="public anchor" id="var-tuple-head-spec-from-stuff"><h3>tuple-head-spec-from-stuff</h3><div class="usage"><code>(tuple-head-spec-from-stuff tuple-stuff)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-tuple-stuffs"><h3>tuple-stuffs</h3><div class="usage"></div><div class="doc"><div class="markdown"><h1><a href="#tuple-specs" id="tuple-specs"></a>Tuple Specs</h1>
<p>There are six tuple heads. Their names will change from run-to-run because the names are gensymmed.</p>
</div></div></div><div class="public anchor" id="var-tuple-stuffss-by-term"><h3>tuple-stuffss-by-term</h3><div class="usage"></div><div class="doc"><div class="markdown"><h2><a href="#tuple-term-specs" id="tuple-term-specs"></a>Tuple Term-Specs</h2>
<p>As before, we really need clojure.specs for the terms corresponding to the heads.</p>
<h3><a href="#tuple-stuffss-sic-by-term-one-extra-level-of-lists" id="tuple-stuffss-sic-by-term-one-extra-level-of-lists"></a>Tuple Stuffss <a href="sic">sic</a> by Term (one extra level of lists)</h3>
</div></div></div><div class="public anchor" id="var-tuple-term-spec-from-stuffs"><h3>tuple-term-spec-from-stuffs</h3><div class="usage"><code>(tuple-term-spec-from-stuffs stuffs)</code></div><div class="doc"><div class="markdown"></div></div></div></div></body></html>