<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>asr.core documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Asr</span> <span class="project-version">0.1.0-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="intro.html"><div class="inner"><span>Introduction to asr</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>asr</span></div></div></li><li class="depth-2 branch"><a href="asr.asr.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>asr</span></div></a></li><li class="depth-2 branch"><a href="asr.autospecs.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>autospecs</span></div></a></li><li class="depth-2 branch current"><a href="asr.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="asr.data.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>data</span></div></a></li><li class="depth-2 branch"><a href="asr.grammar.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>grammar</span></div></a></li><li class="depth-2 branch"><a href="asr.parsed.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>parsed</span></div></a></li><li class="depth-2 branch"><a href="asr.specs.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>specs</span></div></a></li><li class="depth-2"><a href="asr.utils.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>utils</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="asr.core.html#var--main"><div class="inner"><span>-main</span></div></a></li><li class="depth-1"><a href="asr.core.html#var-asr-i32-unchecked-binop-.3Eclojure-op"><div class="inner"><span>asr-i32-unchecked-binop-&gt;clojure-op</span></div></a></li><li class="depth-1"><a href="asr.core.html#var-bigint.3F"><div class="inner"><span>bigint?</span></div></a></li><li class="depth-1"><a href="asr.core.html#var-check-registry"><div class="inner"><span>check-registry</span></div></a></li><li class="depth-1"><a href="asr.core.html#var-count-asr-core-specs"><div class="inner"><span>count-asr-core-specs</span></div></a></li><li class="depth-1"><a href="asr.core.html#var-fast-int-exp-cam-maybe-pluggable"><div class="inner"><span>fast-int-exp-cam-maybe-pluggable</span></div></a></li><li class="depth-1"><a href="asr.core.html#var-fast-int-exp-pluggable"><div class="inner"><span>fast-int-exp-pluggable</span></div></a></li><li class="depth-1"><a href="asr.core.html#var-fast-unchecked-i32-exp"><div class="inner"><span>fast-unchecked-i32-exp</span></div></a></li><li class="depth-1"><a href="asr.core.html#var-fast-unchecked-i32-exp-cam-maybe"><div class="inner"><span>fast-unchecked-i32-exp-cam-maybe</span></div></a></li><li class="depth-1"><a href="asr.core.html#var-i32-bin-op-leaf-semsem-gen-pluggable"><div class="inner"><span>i32-bin-op-leaf-semsem-gen-pluggable</span></div></a></li><li class="depth-1"><a href="asr.core.html#var-i32-bin-op-rhs-gen"><div class="inner"><span>i32-bin-op-rhs-gen</span></div></a></li><li class="depth-1"><a href="asr.core.html#var-i32-bin-op-semsem-gen-pluggable"><div class="inner"><span>i32-bin-op-semsem-gen-pluggable</span></div></a></li><li class="depth-1"><a href="asr.core.html#var-maybe-value-i32-semsem"><div class="inner"><span>maybe-value-i32-semsem</span></div></a></li><li class="depth-1"><a href="asr.core.html#var-only-asr-specs"><div class="inner"><span>only-asr-specs</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">asr.core</h1><div class="doc"><div class="markdown"></div></div><div class="public anchor" id="var--main"><h3>-main</h3><div class="usage"><code>(-main &amp; args)</code></div><div class="doc"><div class="markdown"><p>I don’t do a whole lot … yet.</p>
</div></div></div><div class="public anchor" id="var-asr-i32-unchecked-binop-.3Eclojure-op"><h3>asr-i32-unchecked-binop-&gt;clojure-op</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Substitute particular arithmetic ops for spec ops in Clojure. Our arithmetic is double-pluggable: the power operations is pluggable (see <code>fast-unchecked-i32-exp</code>, and the entire collection of operations is pluggable, one level up.</p>
</div></div></div><div class="public anchor" id="var-bigint.3F"><h3>bigint?</h3><div class="usage"><code>(bigint? n)</code></div><div class="doc"><div class="markdown"><p>Doesn’t seem to be defined in system-supplied libraries.</p>
</div></div></div><div class="public anchor" id="var-check-registry"><h3>check-registry</h3><div class="usage"><code>(check-registry)</code></div><div class="doc"><div class="markdown"><p>Print specs defined in the various namespaces. Call this at the REPL (replacing missing codox for specs).</p>
</div></div></div><div class="public anchor" id="var-count-asr-core-specs"><h3>count-asr-core-specs</h3><div class="usage"><code>(count-asr-core-specs)</code></div><div class="doc"><div class="markdown"><p>Count the asr.core specs. Call this at the REPL.</p>
</div></div></div><div class="public anchor" id="var-fast-int-exp-cam-maybe-pluggable"><h3>fast-int-exp-cam-maybe-pluggable</h3><div class="usage"><code>(fast-int-exp-cam-maybe-pluggable mul div sub underflow-val x n)</code></div><div class="doc"><div class="markdown"><p>O(lg(n)) x^n, x, n zero, pos, or neg, pluggable primitives for base operations in the maybe monad of clojure.algo.monads, more composable than alternatives that check for zero to negative powers. Produces <code>nil</code> if <code>(zero? x)</code> and <code>(neg? n)</code>. Produces <code>underflow-val</code> on underflow.</p>
<p>Partially evaluate this on its operations, for example:</p>
<pre><code>(partial fast-int-exp-pluggable
         unchecked-multiply-int,
         unchecked-divide-int,
         unchecked-subtract-int,
         Integer/MIN_VALUE)
</code></pre>
<p>or</p>
<pre><code>(partial fast-int-exp-pluggable
         unchecked-multiply-int,
         unchecked-divide-int,
         unchecked-subtract-int,
         0)
</code></pre>
</div></div></div><div class="public anchor" id="var-fast-int-exp-pluggable"><h3>fast-int-exp-pluggable</h3><div class="usage"><code>(fast-int-exp-pluggable mul div sub underflow-val x n)</code></div><div class="doc"><div class="markdown"><p>O(lg(n)) x^n, x, n zero, pos or neg, pluggable primitives for base operations. Asserts if (zero? x) and (neg? n). Produces <code>underflow-val</code> on underflow.</p>
<p>Partially evaluate this on its operations, for example:</p>
<pre><code>(partial fast-int-exp-pluggable
         unchecked-multiply-int,
         unchecked-divide-int,
         unchecked-subtract-int,
         Integer/MIN_VALUE)
</code></pre>
<p>or</p>
<pre><code>(partial fast-int-exp-pluggable
         unchecked-multiply-int,
         unchecked-divide-int,
         unchecked-subtract-int,
         0)
</code></pre>
</div></div></div><div class="public anchor" id="var-fast-unchecked-i32-exp"><h3>fast-unchecked-i32-exp</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Produces zero for 2^32, 2^33, … . Underflows negative exponents to 0 (Integer/MIN_VALUE?). Spins unchecked multiplications. Spins large (&gt;= 32) powers of 2 on 0. See core_test.clj</p>
</div></div></div><div class="public anchor" id="var-fast-unchecked-i32-exp-cam-maybe"><h3>fast-unchecked-i32-exp-cam-maybe</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Produces <code>(maybe/just 0)</code> for 2^32, 2^33, … . Underflows negative exponents to <code>(maybe/just 0)</code> (or perhaps to `(maybe/just Integer/MIN_VALUE)?). Spins unchecked multiplications. Spins large (&gt;= 32) powers of 2 on 0. See core_test.clj</p>
</div></div></div><div class="public anchor" id="var-i32-bin-op-leaf-semsem-gen-pluggable"><h3>i32-bin-op-leaf-semsem-gen-pluggable</h3><div class="usage"><code>(i32-bin-op-leaf-semsem-gen-pluggable ops-map)</code></div><div class="doc"><div class="markdown"><p>Given an ops-map from ASR binops to implementations, generate i32 ASR IntegerBinOp leaf node. It’s the generator for spec ::i32-bin-op-leaf-semsem</p>
</div></div></div><div class="public anchor" id="var-i32-bin-op-rhs-gen"><h3>i32-bin-op-rhs-gen</h3><div class="usage"><code>(i32-bin-op-rhs-gen left binop)</code></div><div class="doc"><div class="markdown"><p>Generate RHS valid for any plugged-in arithmetic. Avoid zero divisors.</p>
</div></div></div><div class="public anchor" id="var-i32-bin-op-semsem-gen-pluggable"><h3>i32-bin-op-semsem-gen-pluggable</h3><div class="usage"><code>(i32-bin-op-semsem-gen-pluggable ops-map)</code></div><div class="doc"><div class="markdown"><p>Given an ops-map from ASR binops to implementations, generate an i32 ASR IntegerBinOp node, recursively. TODO: put in cam’s maybe monad.</p>
</div></div></div><div class="public anchor" id="var-maybe-value-i32-semsem"><h3>maybe-value-i32-semsem</h3><div class="usage"><code>(maybe-value-i32-semsem icobo)</code></div><div class="doc"><div class="markdown"><p>Given an IntegerConstant or an IntegerBinOp (icobo), fetch the value, if there is one. Return it in cam’s maybe monad: get nil if there is anything invalid about the input. An IntegerBinOp is semsem-valid if its two inputs, left and right, are semsem-valid and its output value equals the operator applied to the two inputs.</p>
<p>There are two difficult cases: explicit Div by zero and zero to a negative Pow, an implicit div-by-0 (0^0 is defined as 1). Because they both reduce to div-by-0, they are instances of the same difficult case.</p>
<p>Alternative 1 (structural) is to exclude these cases, i.e., never generate instances of div-by0.</p>
<p>Alternative 2 (arithmetic) is to include these cases with an overflow sigil like Integer/MAX_VALUE in the value slot. Because the purpose of this entire project is to generate test strings for ASR back ends, and because instances might trip bugs in the back ends, this alternative is viable.</p>
<p>Because the arithmetic is pluggable, both alternatives are easy to implement.</p>
</div></div></div><div class="public anchor" id="var-only-asr-specs"><h3>only-asr-specs</h3><div class="usage"><code>(only-asr-specs asr-namespace-string)</code></div><div class="doc"><div class="markdown"><p>Filter non-ASR specs from the keys of the spec registry.</p>
</div></div></div></div></body></html>