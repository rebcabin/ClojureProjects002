<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>asr.parsed documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Asr</span> <span class="project-version">0.1.0-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="intro.html"><div class="inner"><span>Introduction to asr</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>asr</span></div></div></li><li class="depth-2 branch"><a href="asr.asr.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>asr</span></div></a></li><li class="depth-2 branch"><a href="asr.autospecs.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>autospecs</span></div></a></li><li class="depth-2 branch"><a href="asr.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="asr.data.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>data</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>expr</span></div></div></li><li class="depth-3"><a href="asr.expr.integer-bin-op.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>integer-bin-op</span></div></a></li><li class="depth-2 branch"><a href="asr.grammar.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>grammar</span></div></a></li><li class="depth-2 branch"><a href="asr.numbers.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>numbers</span></div></a></li><li class="depth-2 branch current"><a href="asr.parsed.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>parsed</span></div></a></li><li class="depth-2 branch"><a href="asr.sandbox.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>sandbox</span></div></a></li><li class="depth-2 branch"><a href="asr.specs.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>specs</span></div></a></li><li class="depth-2 branch"><a href="asr.stats.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>stats</span></div></a></li><li class="depth-2"><a href="asr.utils.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>utils</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="asr.parsed.html#var-asdl-form"><div class="inner"><span>asdl-form</span></div></a></li><li class="depth-1"><a href="asr.parsed.html#var-big-list-of-stuff"><div class="inner"><span>big-list-of-stuff</span></div></a></li><li class="depth-1"><a href="asr.parsed.html#var-big-map-of-speclets-from-terms"><div class="inner"><span>big-map-of-speclets-from-terms</span></div></a></li><li class="depth-1"><a href="asr.parsed.html#var-decl-map"><div class="inner"><span>decl-map</span></div></a></li><li class="depth-1"><a href="asr.parsed.html#var-hashmap-from-speclet"><div class="inner"><span>hashmap-from-speclet</span></div></a></li><li class="depth-1"><a href="asr.parsed.html#var-head-from-kind-form"><div class="inner"><span>head-from-kind-form</span></div></a></li><li class="depth-1"><a href="asr.parsed.html#var-kind-from-form"><div class="inner"><span>kind-from-form</span></div></a></li><li class="depth-1"><a href="asr.parsed.html#var-map-pair-from-speclet-map"><div class="inner"><span>map-pair-from-speclet-map</span></div></a></li><li class="depth-1"><a href="asr.parsed.html#var-shallow-map-from-speclet"><div class="inner"><span>shallow-map-from-speclet</span></div></a></li><li class="depth-1"><a href="asr.parsed.html#var-speclets"><div class="inner"><span>speclets</span></div></a></li><li class="depth-1"><a href="asr.parsed.html#var-stuff-from-term-form"><div class="inner"><span>stuff-from-term-form</span></div></a></li><li class="depth-1"><a href="asr.parsed.html#var-symconst-stuffs"><div class="inner"><span>symconst-stuffs</span></div></a></li><li class="depth-1"><a href="asr.parsed.html#var-symconst-stuffss-by-term"><div class="inner"><span>symconst-stuffss-by-term</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">asr.parsed</h1><div class="doc"><div class="markdown"></div></div><div class="public anchor" id="var-asdl-form"><h3>asdl-form</h3><h4 class="type">multimethod</h4><div class="usage"></div><div class="doc"><div class="markdown"><p>Convert three <code>ASDL</code> kinds, <code>ASDL-SYMCONST</code>, <code>ASDL-COMPOSITE</code>, and <code>ASDL-TUPLE</code>, into Clojure hashmaps</p>
</div></div></div><div class="public anchor" id="var-big-list-of-stuff"><h3>big-list-of-stuff</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>A <strong><em>stuff</em></strong> is a map of <code>:head</code>, <code>:term</code>, <code>:kind</code>, and <code>:form</code> for the approximately 227 heads &amp; forms of ASR. A stuff is all we need for making clojure.specs from terms, heads, &amp; forms. The stuff keywords <code>:head</code>, <code>:term</code>, <code>:kind</code>, and <code>:form</code> need not be namespaced.</p>
<p>Example of a <em>stuff</em>:</p>
<pre><code>{:head :asr.autospecs/Source,
 :term :asr.autospecs/abi,
 :kind :ASDL-SYMCONST,
 :form {:ASDL-SYMCONST "Source"}}
</code></pre>
<p>This big list of stuff is like a big, flat, denormalized database table.</p>
<h2><a href="#kinds" id="kinds"></a>Kinds</h2>
<p>There are three kinds of stuffs: <code>ASDL-COMPOSITE</code>, which look like function declarations with a head and args in parentheses; <code>ASDL-SYMCONST</code>, which are symbolic constants, and <code>ASDL-TUPLE</code>, which look like headless arg lists. The kinds are distinguished by the <code>:kind</code> field.</p>
<h2><a href="#terms" id="terms"></a>Terms</h2>
<p><strong><em>Terms</em></strong> are the things to the left of an equals sign in the ASDL grammar (namespace <code>asr.asr</code>). For example, in the ASDL production</p>
<pre><code>abi                   -- External     ABI
  = Source          --   No         Unspecified
  | LFortranModule  --   Yes        LFortran
  | GFortranModule  --   Yes        GFortran
  | BindC           --   Yes        C
  | Interactive     --   Yes        Unspecified
  | Intrinsic       --   Yes        Unspecified
</code></pre>
<p><code>abi</code> is a term. <code>Source</code> is a generalized head, as we see next.</p>
<h2><a href="#generalized-heads" id="generalized-heads"></a>Generalized Heads</h2>
<p>For composites, the “head” is obvious because it’s a symbol followed by an <code>ASDL-ARGS</code> tuple in parentheses. Example:</p>
<p>ASDL:</p>
<pre><code>case_stmt = CaseStmt(expr* test, stmt* body)
</code></pre>
<p>stuff:</p>
<pre><code>{:head :asr.autospecs/CaseStmt,
 :term :asr.autospecs/case_stmt,
 :kind :ASDL-COMPOSITE,
 :form
 {:ASDL-COMPOSITE
  {:ASDL-HEAD "CaseStmt",
   :ASDL-ARGS
   ({:ASDL-TYPE "expr",
     :MULTIPLICITY :asr.parsed/zero-or-more,
     :ASDL-NYM "test"}
    {:ASDL-TYPE "stmt",
     :MULTIPLICITY :asr.parsed/zero-or-more,
     :ASDL-NYM "body"})}}}
</code></pre>
<p>For symconsts, the “heads” are just the symbolic constants themselves. Example:</p>
<pre><code>{:head :asr.autospecs/Source,
 :term :asr.autospecs/abi,
 :kind :ASDL-SYMCONST,
 :form {:ASDL-SYMCONST "Source"}}
</code></pre>
<p>For all tuples, the head is gensymmed. Example:</p>
<p>ASDL:</p>
<pre><code>call_arg = (expr? value)
</code></pre>
<p>stuff:</p>
<pre><code>{:head :asr.autospecs/asr-tuple2595,
 :term :asr.autospecs/call_arg,
 :kind :ASDL-TUPLE,
 :form
 {:ASDL-TUPLE "asr-tuple2595",
  :ASDL-ARGS
  ({:ASDL-TYPE "expr",
    :MULTIPLICITY :asr.parsed/at-most-once,
    :ASDL-NYM "value"})}}
</code></pre>
<p>The head is <code>:asr.autospecs/asr-tuple2595</code> (kebab-case; exception to the rule for heads), corresponds to term <code>:asr.autospecs/call_arg</code>, in snake case, like all terms. Gensyms change every time the program runs.</p>
<h2><a href="#dont-kebab-too-early" id="dont-kebab-too-early"></a>Don’t Kebab Too Early</h2>
<p>Heads, except for gensymmed heads for tuples, are in PascalCase; don’t kebab them. We’ll kebab the derived namespaced keywords for naming clojure.specs in namespace <code>asr.autospecs</code>.</p>
<h2><a href="#how-to-helper-stuff-from-term-form" id="how-to-helper-stuff-from-term-form"></a>How-to-Helper: Stuff from Term &amp; Form</h2>
<p>Partially evaluate <code>stuff-from-term-form</code> on a term, then map the result over all the forms for that term.</p>
</div></div></div><div class="public anchor" id="var-big-map-of-speclets-from-terms"><h3>big-map-of-speclets-from-terms</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Make a big, inverted index of about 227 heads from about 28 terms.</p>
<p>Example: term <code>::symbol</code> maps to <code>::Function</code>, <code>::Program</code>, <code>::Module</code>, and more.</p>
<p>Except for <code>SymbolTable</code>, which is not written in ASDL, terms are in <code>snake_case</code>.</p>
</div></div></div><div class="public anchor" id="var-decl-map"><h3>decl-map</h3><div class="usage"><code>(decl-map decl-hiccup)</code></div><div class="doc"><div class="markdown"><p>Convert hiccup <code>[:ASDL-DECL [:ASDL-TYPE ...] [:ASDL-NYM ...]]</code> into <code>{:ASDL-TYPE ..., :MULTIPLICITY ..., :ASDL-NYM ...}</code>. Used to convert <code>ASDL-COMPOSITES</code> and <code>ASDL-TUPLES</code>. TODO: Rewrite argument validation with s/fdef.</p>
</div></div></div><div class="public anchor" id="var-hashmap-from-speclet"><h3>hashmap-from-speclet</h3><div class="usage"><code>(hashmap-from-speclet speclet)</code></div><div class="doc"><div class="markdown"><p>Convert one entire speclet to a hashmap.</p>
<p>A speclet is, roughly, <code>ASDL-TERM '=' ASDL-FORM*</code></p>
</div></div></div><div class="public anchor" id="var-head-from-kind-form"><h3>head-from-kind-form</h3><div class="usage"><code>(head-from-kind-form kind form)</code></div><div class="doc"><div class="markdown"><p>Get the generalize head from a <code>kind</code> and a form.</p>
</div></div></div><div class="public anchor" id="var-kind-from-form"><h3>kind-from-form</h3><div class="usage"><code>(kind-from-form form)</code></div><div class="doc"><div class="markdown"><p>Get the <code>kind</code> from an ASDL form. The kind is one of <code>ASDL-COMPOSITE</code>, <code>ASDL-SYMCONST</code>, or <code>ASDL-TUPLE</code>.</p>
</div></div></div><div class="public anchor" id="var-map-pair-from-speclet-map"><h3>map-pair-from-speclet-map</h3><div class="usage"><code>(map-pair-from-speclet-map speclet-map)</code></div><div class="doc"><div class="markdown"><p>Convert a speclet hashmap <code>{:ASDL-TERM &lt;term&gt;, :ASDL-FORMS &lt;forms&gt;}</code> into an ordered pair <code>[:ASDL-TERM &lt;term&gt;, :ASDL-FORMS &lt;forms&gt;]</code> in preparation for the inverted index, <code>big-map-of-speclets-from-terms</code>. Prepend the namespace prefix <code>asr.autospecs</code> without kebab’bing.</p>
</div></div></div><div class="public anchor" id="var-shallow-map-from-speclet"><h3>shallow-map-from-speclet</h3><div class="usage"><code>(shallow-map-from-speclet speclet)</code></div><div class="doc"><div class="markdown"><p>Convert an <code>ASDL-DEF</code> into a map from <code>:ASDL-TERM</code> to the name of the term of the speclet and from <code>:ASDL-FORMS</code> into a list of alternative forms, still in hiccup format awaiting deeper conversion.</p>
</div></div></div><div class="public anchor" id="var-speclets"><h3>speclets</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Big vector. Strip off the <code>module</code> info, leaving only ASDL-DEFs, i.e., <em>speclets</em>.</p>
</div></div></div><div class="public anchor" id="var-stuff-from-term-form"><h3>stuff-from-term-form</h3><div class="usage"><code>(stuff-from-term-form term form)</code></div><div class="doc"><div class="markdown"><p>Construct a <em>stuff</em> from a <code>term</code> and a form. Prepend the namespace prefix <code>asr.autospecs</code>, without kebab’bing.</p>
</div></div></div><div class="public anchor" id="var-symconst-stuffs"><h3>symconst-stuffs</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Clojure.specs for symconsts are easiest because they don’t depend on other clojure.specs. There are about 72 symconsts (more as ASR grows):</p>
</div></div></div><div class="public anchor" id="var-symconst-stuffss-by-term"><h3>symconst-stuffss-by-term</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>To check an instance or utterance of ASR like <code>asr.data/expr-221000</code>, we’ll need to check its sub-parts by term, not by head.</p>
<p>Partition the symconst specs by term. There are about 13 terms categorizing the (approx) 72 symconst heads.</p>
</div></div></div></div></body></html>