<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>asr.parsed documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Asr</span> <span class="project-version">0.1.0-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="intro.html"><div class="inner"><span>Introduction to asr</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>asr</span></div></div></li><li class="depth-2 branch"><a href="asr.asr.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>asr</span></div></a></li><li class="depth-2 branch"><a href="asr.autospecs.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>autospecs</span></div></a></li><li class="depth-2 branch"><a href="asr.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="asr.data.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>data</span></div></a></li><li class="depth-2 branch"><a href="asr.grammar.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>grammar</span></div></a></li><li class="depth-2 branch current"><a href="asr.parsed.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>parsed</span></div></a></li><li class="depth-2 branch"><a href="asr.specs.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>specs</span></div></a></li><li class="depth-2"><a href="asr.utils.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>utils</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="asr.parsed.html#var-asdl-form"><div class="inner"><span>asdl-form</span></div></a></li><li class="depth-1"><a href="asr.parsed.html#var-big-list-of-stuff"><div class="inner"><span>big-list-of-stuff</span></div></a></li><li class="depth-1"><a href="asr.parsed.html#var-big-map-of-speclets-from-terms"><div class="inner"><span>big-map-of-speclets-from-terms</span></div></a></li><li class="depth-1"><a href="asr.parsed.html#var-decl-map"><div class="inner"><span>decl-map</span></div></a></li><li class="depth-1"><a href="asr.parsed.html#var-hashmap-from-speclet"><div class="inner"><span>hashmap-from-speclet</span></div></a></li><li class="depth-1"><a href="asr.parsed.html#var-head-from-kind-form"><div class="inner"><span>head-from-kind-form</span></div></a></li><li class="depth-1"><a href="asr.parsed.html#var-kind-from-form"><div class="inner"><span>kind-from-form</span></div></a></li><li class="depth-1"><a href="asr.parsed.html#var-map-pair-from-speclet-map"><div class="inner"><span>map-pair-from-speclet-map</span></div></a></li><li class="depth-1"><a href="asr.parsed.html#var-shallow-map-from-speclet"><div class="inner"><span>shallow-map-from-speclet</span></div></a></li><li class="depth-1"><a href="asr.parsed.html#var-speclets"><div class="inner"><span>speclets</span></div></a></li><li class="depth-1"><a href="asr.parsed.html#var-stuff-from-term-form"><div class="inner"><span>stuff-from-term-form</span></div></a></li><li class="depth-1"><a href="asr.parsed.html#var-symconst-stuffs"><div class="inner"><span>symconst-stuffs</span></div></a></li><li class="depth-1"><a href="asr.parsed.html#var-symconst-stuffss-by-term"><div class="inner"><span>symconst-stuffss-by-term</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">asr.parsed</h1><div class="doc"><pre class="plaintext"></pre></div><div class="public anchor" id="var-asdl-form"><h3>asdl-form</h3><h4 class="type">multimethod</h4><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-big-list-of-stuff"><h3>big-list-of-stuff</h3><div class="usage"></div><div class="doc"><pre class="plaintext"># Big List of Stuff

A ***stuff*** is a map of `:head`, `:term`, `:kind`, and `:form`
for the approximately 227 heads &amp; forms of ASR. A stuff is all
we need for making clojure.specs from terms, heads, &amp; forms. The
stuff keywords `:head`, `:term`, `:kind`, and `:form` need not
be namespaced.

This big list of stuff is like a big, flat, denormalized
database table.

## Generalized Heads

For composites, the "head" is obvious because it's a symbol
followed by an args tuple.

For symconsts, the "heads" are just the symbolic constants
themselves.

For all tuples, the head is gensymmed. Example: head
`::asr-tuple3805` (kebab-case; exception to the rule for heads),
corresponds to term `::alloc_arg`, in snake case, like all
terms.

### Don't Kebab Too Early

Heads, except for gensymmed heads for tuples, are in PascalCase;
don't kebab them. We'll kebab the derived namespaced keywords
for naming clojure.specs.

## Helper: Stuff from Term &amp; Form

Here we go again, illiterates! Gotta show you how we're doing it
before showing you what we're doing!

The intention is to partially evaluate `stuff-from-term-form` on
a term, then map the result over all the forms for that term.
</pre></div></div><div class="public anchor" id="var-big-map-of-speclets-from-terms"><h3>big-map-of-speclets-from-terms</h3><div class="usage"></div><div class="doc"><pre class="plaintext"># Big Map of Speclets From Terms

Example: term `::symbol` maps to `::Function`, `::Program`,
`::Module`, and more.

Except for `SymbolTable`, which is not written, terms are in
`snake_case`.

Have fun clicking around the large output of this cell. There
are about 28 terms with about 227 heads.
</pre></div></div><div class="public anchor" id="var-decl-map"><h3>decl-map</h3><div class="usage"><code>(decl-map decl-hiccup)</code></div><div class="doc"><pre class="plaintext">Convert [:ASDL-DECL [:ASDL-TYPE ...] [:ASDL-NYM ...]] into
{:ASDL-TYPE ..., :MULTIPLICITY ..., :ASDL-NYM ...}.
Used to convert ASDL-COMPOSITES and ASDL-TUPLES.
TODO: Rewrite argument validation with s/fdef.</pre></div></div><div class="public anchor" id="var-hashmap-from-speclet"><h3>hashmap-from-speclet</h3><div class="usage"><code>(hashmap-from-speclet speclet)</code></div><div class="doc"><pre class="plaintext">## Hashmap from Speclet, Itself

A speclet is, roughly, ASDL-TERM '=' ASDL-FORM*

One entire speclet to a hashmap:
</pre></div></div><div class="public anchor" id="var-head-from-kind-form"><h3>head-from-kind-form</h3><div class="usage"><code>(head-from-kind-form kind form)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-kind-from-form"><h3>kind-from-form</h3><div class="usage"><code>(kind-from-form form)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-map-pair-from-speclet-map"><h3>map-pair-from-speclet-map</h3><div class="usage"><code>(map-pair-from-speclet-map speclet-map)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-shallow-map-from-speclet"><h3>shallow-map-from-speclet</h3><div class="usage"><code>(shallow-map-from-speclet speclet)</code></div><div class="doc"><pre class="plaintext">Convert an ASDL-DEF into a map from :ASDL-TERM to the name of the
term of the speclet and from :ASDL-FORMS into a list of
alternative forms, still in hiccup format awaiting deeper
conversion.</pre></div></div><div class="public anchor" id="var-speclets"><h3>speclets</h3><div class="usage"></div><div class="doc"><pre class="plaintext">## Raw Hiccup for all Speclets

Strip off the `module` info, leaving only ASDL-DEFs, i.e.,
*speclets*.
</pre></div></div><div class="public anchor" id="var-stuff-from-term-form"><h3>stuff-from-term-form</h3><div class="usage"><code>(stuff-from-term-form term form)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-symconst-stuffs"><h3>symconst-stuffs</h3><div class="usage"></div><div class="doc"><pre class="plaintext"># All Symconst Specs

Clojure.specs for symconsts are easiest because they don't
depend on other clojure.specs. There are about 72
symconsts (more as ASR grows):

## Symconst Stuffs
</pre></div></div><div class="public anchor" id="var-symconst-stuffss-by-term"><h3>symconst-stuffss-by-term</h3><div class="usage"></div><div class="doc"><pre class="plaintext">## Symconst-Term-Specs

To check an instance or utterance of ASR like expr-221000, we'll
need to check its sub-parts by term, not by head.

### Symconst Stuffss sic by Term

First, partition the symconst specs by term. There are about 13
terms categorizing the (approx) 72 symconst heads.
</pre></div></div></div></body></html>